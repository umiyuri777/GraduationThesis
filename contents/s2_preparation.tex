\section{関連技術}
\subsection{オープンワールドゲーム}
オープンワールドゲームとは，探索可能な空間やメカニクス，目標の選択において，プレイヤに高い自律性が与えられているビデオゲームのジャンルである\cite{Alexander2017}．従来のゲームに見られるような，開発者によって事前に設定された線形なゲーム形式とは対照的に，オープンワールドゲームではプレイヤ自身が行動の結果を試し，目標を決定する自由が与えられているため，非線形なゲーム形式となることが特徴である\cite{Alexander2017}．

しかし，こうした自由度の高さはシステムが取りうる状態数を爆発的に増大させるため，テストの自動化を困難にする要因となっている．

\subsection{ファジング}
ファジングとは，ソフトウェアテスト手法の一つである\cite{IPA_Fuzzing}．ファジングでは初期入力列を繰り返し変異させ，ファズという不具合を引き起こしやすい入力列を生成する．ビデオゲームにおけるファズとは，ゲームを開始した初期状態から不具合を引き起こす状態へ遷移する入力列のことを指す．

代表的なファジングツールとして，AFL\cite{AFL}が挙げられる．AFLは，テスト対象プログラムの実行時にコードカバレッジを計測し，その情報を次のファズ生成に利用する．具体的には，対象プログラムのコンパイル時に計測用のコードを分岐命令ごとに埋め込み，実行時に新たな分岐が発見された場合，その入力を保存しておき，重点的に変異させる．このように，まだ到達していない分岐先に遷移するようにファズを生成することで，分岐先のコードを効率的にテストすることができ，コードカバレッジの高いテストを可能にしている．

\subsection{ビデオゲームに対するファジング}
ビデオゲームに対してファジングを適用した既存研究として，AschermannらによるIJON\cite{IJON}がある．彼らは，ビデオゲームのように広大な状態空間と複雑な状態遷移を持つソフトウェアに対しては，従来のコードカバレッジのみに依存したファジングでは探索性能が不十分であると指摘している．そこでIJONでは，人間がプログラム内の重要な変数や関数にアノテーションを追加することで，ファジングの探索を誘導する手法を提案した．スーパーマリオブラザーズ\footnote{\url{https://www.nintendo.com/jp/famicom/software/smb1/index.html}}を対象にIJONを適用した実験を行い，従来のAFLでは到達困難であったゲームの後半ステージや隠しエリアへの到達に成功している．

しかし，AFLやIJONといった既存のツールを，近年のオープンワールドゲームへそのまま適用するには技術的課題が存在する．第一に，これらのツールは主にC言語で記述されたプログラムを対象としており，コンパイル時に計測コードを埋め込む必要がある．現在のゲーム開発ではゲームエンジン\footnote{\url{https://www.sca.ac.jp/contents/glossary/?glossary=game_engine}}を使用することが主流となっているため，AFLをそのまま適用することは難しい．第二に，入力形式の違いである．AFLは主にファイルや標準入力を対象とするが，オープンワールドゲームでは複数の入力を同時に行うことが必要となるため，AFLをそのまま適用することは難しい．

これらの理由から，既存のファジングツールをそのままオープンワールドゲームのテストに導入することは難しく，ゲームエンジン上で動作し，かつゲーム特有の入力形式に対応した新たなファジングの枠組みが必要とされている．

\subsection{オープンワールドゲームに対するファジングの適用}
オープンワールドゲームに対するファジングの適用事例として，Katoらによって提案されたBiFuzz\cite{Kato2024}が挙げられる．BiFuzzは，オープンワールドゲーム特有の課題である広大な状態空間に対応するため，大域的ファジングと局所的ファジングという2段階でのファジングを行うことが特徴である．
前節で述べた通り，オープンワールドゲームは自由度が高いために状態数が膨大になる．そのため，網羅的な探索が困難であり，ランダム入力では効率的な探索ができない．これに対しBiFuzzでは，2段階でファジングを行うことで，人間らしい動作をする入力列を生成する．このように，プレイヤとしてあり得る挙動で探索可能な範囲に状態空間を限定することで，従来は困難であったオープンワールドゲームに対するファジングの実行を可能にしている．

BiFuzzにおいて重要となるのがパラメータの設定である．BiFuzzはパラメータによってプレイヤの動作が決定されるため，パラメータの組み合わせによって不具合発見の確率が変化するという特徴がある．中には不具合発見の確率が低いパラメータの組み合わせも存在するため，そのようなパラメータ設定のままテストを実行し続けることは限られた開発リソースの浪費につながる．したがって，パラメータの組み合わせから実行結果を事前に予測し，効率的に不具合を発見できる設定を特定することは，テスト実行時間の短縮と効率化を図る上で有益である．

% \subsection{ファジング実行結果の予測} 
% ファジングの実行結果や有効性を事前に予測する試みとして，統計的アプローチを用いたフレームワークであるSTADS\cite{STADS}が存在する．STADSは，生態学における「種の発見」のモデルをソフトウェアテストに応用したものである．この手法では，ファジングによって発見されるコードカバレッジを「種」，テスト入力を「個体」と見なし，これまでに発見されたカバレッジの頻度分布からChao推定量やGood-Turing推定法などの統計モデルを適用することで，未発見のコードカバレッジの割合や，ファジングが最終的に到達可能な総カバレッジを推定している.

% STADSは，ソフトウェアテストを生態学における種の発見問題としてモデル化する手法である．このモデルでは，発見されたカバレッジ要素の出現頻度分布，特に1回または2回しか実行されていない稀な要素の数に着目する．稀な種の数が多いほど未発見の要素も多いとされる生態学の知見に基づき，Chao2やJackknifeといった推定量を用いることで，未だ発見されていないカバレッジ要素の総数や到達可能な最大カバレッジを動的に推定し，静的解析では困難な，これ以上実行しても成果が得にくいファジングの飽和点の判断を可能にしている．これにより，ファジングを停止すべき時期や，ファザーが不具合発見する余地がどれほど残されているかを数理的に判断するための基盤を提供する．

% しかし，既存の手法では，カバレッジの飽和を検知し，ファジングをいつ停止すべきかを判断することを主目的としており，ファジングを実行した結果を予測するものではない．また，既存の手法では予測の指標として主にコードカバレッジに依存しているという課題がある．ビデオゲームにおける不具合の多くは，特定の順序でのアクションや複雑な状態遷移の組み合わせによって発生するため，単にプログラムのコード行を通過しただけでは不具合の発見には直結しない場合が多い．コードカバレッジのみを指標とした予測では，ビデオゲーム特有の不具合の発見効率を正しく評価することは困難である．したがって，オープンワールドゲームを対象とする本研究においては，コードカバレッジに依存した既存の統計的予測手法を適用することは適さない．


\subsection{ファジング実行結果の予測}
ファジングの実行結果や有効性を予測する試みとして，統計的アプローチを用いたフレームワークであるSTADS (Software Testing as Species Discovery) \cite{STADS}が存在する．STADSは，ソフトウェアテストを生態学における「種の発見」になぞらえてモデル化した手法である．生態学者が限られたサンプルから森林全体の生物種の総数を推定するように，STADSではファジング中に観測された実行パスやカバレッジ項目などを「種」とし，この頻度分布を用いてプログラム全体の挙動や未発見のパス数を統計的に推論する．このフレームワークの最大の特徴は，1回や2回しか実行されていないパスなどの「発見された希少種の情報が，未発見の種に関する情報の多くを説明する」という仮説に基づいている点である．Chao推定やGood-Turing推定といった指標を用いることで，プログラムのバグやパスの総数などを推定することができる．これらの指標を用いることで，従来は経験則に頼っていたファジングの停止判断や，追加のリソースを投じた場合に得られる成果の予測を定量的に行うことが可能となる．

しかし，STADSの統計モデルが正しく機能するためには，同じ入力が与えられれば何度実行しても常に同じ種に分類される決定的な実行が前提条件となっている．本研究で対象とするオープンワールドゲームのファジングでは，同じパラメータでも実行結果が変わる非決定性を含んでおり，同じ入力でも常に同じ種に分類できない．そのため，本研究においてSTADSを適用することは適さない．