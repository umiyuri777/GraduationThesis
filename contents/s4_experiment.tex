\section{実験}\label{sec:experiment}
本章では，\chapref{sec:proposal}で提案した提案手法の有効性を検証するために実施した実験について述べる．

\figref{fig:testflow}に本実験の流れを示す．本実験では，BiFuzzに対して様々なパラメータについて5回ずつ適用してテストを実行し，不具合発見の成否を実験結果として記録する．
そして，収集したデータに対し，提案手法の有効性を評価するためのアルゴリズムとして，ロジスティック回帰分析，決定木，ランダムフォレストの3つを採用し，以下の3つの項目に関して予測モデルの構築を試みる．
\begin{itemize}
    \item \testfirst
    \item \testsecond
    \item \testthird
\end{itemize}
構築した各モデルの性能を評価するために，データセットを用いた10分割交差検証を行い，評価指標として適合率，再現率，F値を算出する．不具合発見の予測の正確性を比較するため，「すべてのテストケースで不具合を発見すると予測する」というベースラインを用意し，比較する．

\begin{figure}[H]
    \begin{center}
        \includegraphics[height=200mm]{img/test_method_1.png}
        \caption{実験の概要図}
        \label{fig:testflow}
    \end{center}
\end{figure}
% \begin{figure}[H]
%     \begin{center}
%     \hspace{-15mm}
%         \includegraphics[height=200mm]{img/test_method.png}
%         \caption{実験の概要図}
%         \label{fig:testflow}
%     \end{center}
% \end{figure}


\subsubsection*{実験目的}
本実験の目的は2つある．
1つ目は，パラメータ設定から不具合発見を予測するモデルの構築を試み，その予測精度および有効性を評価することである．
2つ目は，不具合発見とマップ構造の相関を明らかにすることで，提案手法における適用プロセスの妥当性を検証することである．また，これらの調査に向けて以下の2つのRQを設定した．

\begin{description}
    \item[RQ1:] \rqfirst
    \item[RQ2:] \rqsecond
\end{description}


\subsubsection*{実験設定}
% 本実験では局所ファジングのパラメータに焦点を当てて行う．これは本実験で検出対象として埋め込んだ不具合がスタックであるためである．スタックは主に地形やオブジェクトとの衝突判定によって発生するため，大まかなタスク順序を決定する大域的ファジングよりも，具体的な移動経路や経由地を決定する局所的ファジングの影響度が支配的であると考えられる．

本実験では，不具合発見の要因を分析するために，以下の計4つのパラメータを採用した．これらは，BiFuzzのテストケース生成に使用されるパラメータと，本実験のために独自に追加したマップに関するパラメータに大別される．

BiFuzzにおいて，テストケース（移動経路）の生成に直接関与する以下の3つのパラメータをすべて採用した．
\begin{itemize}
    \item \textbf{cpNum}: 経由地の数
    \item \textbf{cpNum\_range}:経由地の生成範囲
    \item \textbf{cpNum\_dir}: 経由地の生成方向
\end{itemize}
これらを採用した理由は，BiFuzzの局所的ファジングにおいて経路決定に使用されるすべてのパラメータを網羅することで，パラメータが不具合発見に与える影響を漏れなく評価するためである．\\
マップ環境を変化させるためのパラメータとして，本実験で独自に以下を採用した．
\begin{itemize}
    \item \textbf{tree}（障害物となる木の数）: マップ上にランダムに配置される，衝突判定を持つ木のオブジェクトの総数．
\end{itemize}
これを採用した理由は，マップ構造（障害物の密度）の変化を特徴量として含めることで，マップ構造と不具合発見の相関を検証するためである．

実験においてパラメータが取りうる値は連続値ではなく離散的な代表値に限定した．これは，全通りの組み合わせを実行することは時間的制約から現実的ではなく，かつパラメータの微小な値の変化は不具合発見の結果に大きく影響しないと考えられるためである．具体的に採用したパラメータとその値の集合を以下に示す．
\begin{itemize}
    \item \textbf{cpNum} : $\{1, 50, 99, 200, 300, 700\}$
    \item \textbf{cpNum\_range} : $\{1, 50, 99\}$
    \item \textbf{cpNum\_dir} : $\{1, 2, 3, 4\}$
    \item \textbf{tree} : $\{0, 500, 1000\}$
\end{itemize}

また，BiFuzzは同一のパラメータ設定であっても実行結果が異なるような非決定性を含んでいる．この影響を考慮し，上記パラメータの組み合わせ1つにつき5回ずつ実行を行い，データを収集することとした．

今回の実験では\figref{fig:stack_bug_object}のようなスタックする不具合を模したオブジェクトをマップ上に100箇所ランダムに配置する．このオブジェクトは外側からかは侵入可能であるが，内側からは脱出不可能になっている．一定時間このオブジェクトの内側にいると「スタックした」と判定される．
\begin{figure}[H]
    \begin{center}
        \includegraphics{img/sample.png}
        \caption{スタックする不具合を模したオブジェクト}
        \label{fig:stack_bug_object}
    \end{center}
\end{figure}

\subsubsection*{対象ゲーム}実験の対象となるビデオゲームとして，BiFuzzの提案論文\cite{Kato2024}でも使用された「STAR COLLECTION」を採用した．本ゲームは ゲームエンジンであるUnity\footnote{\url{https://unity.com/ja}}を用いて開発された，簡易的なオープンワールドゲームである．ゲームの目的は，広大なマップ上に配置された星のアイテムをすべて回収することである．ゲーム内の環境はシンプルに構成されており，マップ上には\figref{fig:player}のようなプレイヤキャラクタ，\figref{fig:star}のような回収対象となる星のアイテム，そして\figref{fig:tree}のような移動の障害物となる木のオブジェクトのみが存在する．

\subsubsection*{分析の枠組み}前節で述べた通り，BiFuzzの実行結果には非決定性があり，同一のパラメータ設定であっても実行ごとに結果が異なる可能性がある．そこで本実験では，構築する予測モデルの堅牢性を多角的に評価するために，収集したデータに対して以下の3つの異なる粒度で正例を定義し，それぞれについて分析を行うこととした．

\begin{enumerate}
    \item \textbf{1回の実行ごとの分析 }:
    5回の試行をそれぞれ独立したデータとして扱い，1回の実行で不具合を発見できたかを予測対象とする．
    
    \item \textbf{5回の実行のうち1回以上不具合を発見 }:
    パラメータの組み合わせごとに集計を行い，5回の試行のうち少なくとも1回不具合を発見できた場合を正例とする．

    \item \textbf{5回の実行のうち5回とも不具合を発見 }:
    パラメータの組み合わせごとに集計を行い，5回の試行すべてにおいて不具合を発見できた場合のみを正例とする．
\end{enumerate}

\begin{figure}[H]
    \begin{center}
        \includegraphics{img/sample.png}
        \caption{プレイヤキャラクタ}
        \label{fig:player}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics{img/sample.png}
        \caption{星のオブジェクト}
        \label{fig:star}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics{img/sample.png}
        \caption{木のオブジェクト}
        \label{fig:tree}
    \end{center}
\end{figure}

% \section{準備}
% \subsection{関連技術}
% 基本的な \LaTeX の記法は以下になります．
% より詳細な文法については各自でお調べください．
% \subsubsection*{章，節，項}

% \begin{itemize}
% 	\item \verb|\section{章タイトル}|
% 	\item \verb|\subsection{節タイトル}|
% 	\item \verb|\subsubsection{項タイトル}|
% \end{itemize}

% また，\verb|\subsubsection*{タイトル}|と記述すると，見出しの番号が非表示になります．
% 例えば「2.1.1　章，節，項」が「章，節，項」のみの表示となります．


% \subsubsection*{改行}

% \begin{itemize}
% 	\item \verb|\\|
% 	\item \verb|\par|
% 	\item 空白行
% 	\item \verb|\linebreak|
% \end{itemize}

% タイトル内でも改行できるため，適切な位置で改行を挿入してください．
% なお，改行直後の段落では自動で字下げが行われます．
% 字下げしたくない場合は\verb|\noindent|を段落の直前に挿入してください（本texファイル参照）．

% \begin{itembox}[l]{改行の例（ソースコード）}
% 立命館大学 \textbackslash\textbackslash \\
% Ritsumeikan University \textbackslash par \\
% 情報理工学部 \\
% \\
% College of Information Science and Engineering\\
% \\
% \\
% \\
% システムアーキテクトコース \textbackslash linebreak\\
% System Architect Course
% \end{itembox}

% \begin{itembox}[l]{改行の例（出力）}
% 立命館大学 \\
% Ritsumeikan University \par
% 情報理工学部 

% College of Information Science and Engineering



% システムアーキテクトコース \linebreak
% System Architect Course
% \end{itembox}


% \subsubsection*{特殊文字}
% \LaTeX は直接入力ができない文字があります．前項の\verb|\\|もコード中に記入したら改行されてしまい，バックスラッシュが表示されません．
% 他によく使うものだと矢印（ $\rightarrow$ , $\leftarrow$ ）や 波ダッシュ（ $\sim$ ） があります．
% 右向きの矢印は\verb|$\rightarrow$|と入力すると表示されます．
% 波ダッシュは\verb|$\sim$|と記述するか，\verb|\usepackage{textcomp}|などを使うことで記述できます．

% 他，数学記号やギリシャ文字，引用文献の人名におけるウムラウト( \"{a} )やアクセント( \'{o} )なども通常の入力ではエラーが生じる場合があります．
% 必要に応じてコマンドを使用してください．

% \subsubsection*{図}
% 図を挿入する際は，\verb|figure|を用います．
% 図は特に挿入位置を指定する必要は無く，自動で最適な箇所に挿入されます．

% 下記に例を示します．
% 下記は図を挿入しつつ，\verb|\begin{figure}~\end{figure}|で囲むことで図を中央揃えに配置しています．
% 例のように記述した場合，図\ref{fig:samplefig}が表示されます．

% \begin{lstlisting}[language=Tex]
% \begin{figure}[t!]
%     \begin{center}
%        \includegraphic[\linewide]{img/sample.png}
%        \caption{図のサンプル}
%     \end{center}
%     \label{fig:samplefig}
% \end{figure}
% \end{lstlisting}

% \verb|\begin{figure}[t!]|の\verb|[t!]|部分は図の挿入位置です．ソースコードの挿入位置（h），上部（t），下部（b）などがあります．
% 本稿ではレイアウトのため，挿入位置の後に\verb|!|を挿入しています（削除すると図が全て論文末尾に移動します）．

% \verb|option|では画像の横幅（width）縦幅（height），倍率（scale）などを指定できます．
% \verb|\linewidth|はページの横幅と同様の値を指します．

% \verb|filename|で挿入する画像のファイル名を指定し，\verb|caption|にキャプションを記入します．
% ファイル名は相対パスで表記してください．

% \begin{figure}[b!]
%     \begin{center}
%         \includegraphics[width=\textwidth]{img/sample.png}
%         \caption{図のサンプル}
%         \label{fig:samplefig}
%     \end{center}
% \end{figure}


% 例では追加で，\verb|\caption{図のサンプル}|と\verb|\label{fig:samplefig}|を用いています．
% \verb|\caption{…}|でキャプションの指定，
% \verb|\label{…}|の使い方は\ref{sec:refexp}項で行います．

% \subsubsection*{表}
% 表の挿入は\verb|table|を用います．
% 下記の例の場合だと表\ref{table:sampletab}が出力されます．
% \begin{lstlisting}[language=Tex]
% \begin{table}[t]
%  \caption{表のサンプル}
%  \begin{center}     
%   \begin{tabular}{c|lll}
%    \hline
%    ID & キャンパス名 & 略称 & 大学  \\ \hline
%    1 & びわこ・くさつキャンパス & BKC & \multirow{2}{*}{立命館大学}\\
%    2 & 大阪・いばらきキャンパス & BKC & \\ 
%    3 & 豊中キャンパス &  & 大阪大学\\
%    \hline
%   \end{tabular}
%  \end{center}
%  \label{table:sampletab}
% \end{table}

% \end{lstlisting}

% \begin{table}[t]
%  \caption{表のサンプル}
%  \label{table:sampletab}
%  \begin{center}     
%   \begin{tabular}{c|l|l|l}
%    \hline
%    ID & キャンパス名 & 略称 & 大学  \\ \hline
%    1 & びわこ・くさつキャンパス & BKC & \multirow{2}{*}{立命館大学}\\ \
%    2 & 大阪・いばらきキャンパス & OIC & \\  \hline
%    3 & \multicolumn{2}{c|}{豊中キャンパス}  & 大阪大学\\
%    \hline
%   \end{tabular}
%  \end{center}
% \end{table}

% \verb|\caption|や\verb|\label|の使い方は\verb|figure|と同じです．

% \subsubsection*{引用文献，注釈}
% 文献の引用には\textbf{bibtex}を用いています．本論文の場合，texファイルに直接引用文献情報を書かず，\verb|reference.bib|というファイルに引用文献を記載しています．
% 引用方法は\ref{sec:ref}項を参照してください．
% bibファイルの一部を以下に示します．

% \begin{lstlisting}[language=Tex]
% @inproceedings{yoon2012,
%     author={YoungSeok Yoon and Brad A. Myers},
%     title={An Exploratory Study of Backtracking Strategies 
%                                                  Used by Developers},
%     booktitle={Proceedings of the 5th International Workshop on 
%                Cooperative and Human Aspects of Software Engineering},
%     year={2012},
%     month={June},
%     pages={138--144}
% }
% \end{lstlisting}

% 引用する対象が会議，ワークショップ等で発表された論文である場合\linebreak
% \verb|@inproceedings|で始め，論文誌の場合\verb|@article|で始めます．
% その後，例でいう\verb|yoon2012|部分は該当の文献を引用する時の名前になります．
% \verb|author|は著者一覧，\verb|title|は論文タイトル，\verb|booktitle|は発表された会議名（正確には該当論文が収録された予稿集名），\verb|year, month|は発表された年月，\verb|page|はページ番号です．
% 論文誌の場合\verb|booktitle|でなく\verb|journal|になります．より詳細な情報はbibtexの書き方など\footnote{https://mathlandscape.com/latex-bib/ など}で調べて下さい．

% 文献以外で説明の補足を行う場合は注釈機能を用います．
% 注釈とはこのように\footnote{https://卒業論文.com/2020/04/16/post-250/}該当のページ内下部に表示されるため，論文を読むときの補足に使われます．
% 記述は，
% スラッシュやチルダ(\verb|〜|)の文字化け回避のため，\verb|setting.tex|に\verb|\usepackage{url}|と記述しています．

% \subsection{関連技術} \label{sec:related}
% Texファイル内の参照を\ref{sec:refexp}項で，参考文献の引用を\ref{sec:ref}項で行います．
% \subsubsection{Tex内の参照} \label{sec:refexp}
% 特定の章や図表などを参照する際，数値を直接入力すると，章や図表を新しく挿入した際，参照番号がずれてしまう恐れがあります．
% そのため，Latexでは\textbf{相互参照}の機能があります．

% 相互参照の流れは，(1)参照したい章や図表に\verb|label|を付与し，
% (2)そのラベルを\verb|ref|コマンドで参照します．

% 例えば，\ref{sec:related}節から\ref{sec:refexp}項までのソースコードは下記のようになっています（わかりやすいように一部修正しています）．

% \begin{lstlisting}[language=Tex]
% \subsection{関連技術} 
% Texファイル内の参照を\ref{sec:refexp}項で，
%             参考文献の引用を\ref{sec:ref}項で行います．

% \subsubsection{Tex内の参照} \label{sec:refexp}
% 特定の章や図表などを参照する際，数値を直接入力すると…（略）
% \end{lstlisting}

% 上記をコンパイルすると，下記のように出力されます．

% \begin{lstlisting}[language=Tex]
% 2.2 関連技術
% 　Texファイル内の参照を2.2.1項で，参考文献の引用を2.2.2項で行います．

% 2.2.1 Tex内の参照
% 　特定の章や図表などを参照する際，数値を直接入力すると…（略）
% \end{lstlisting}

% 相互参照を利用することで，例えば2.2.1項に新しい章が挿入され，現在の2.2.1項が2.2.2項や2.3.1項などに変化したとしても，\verb|``Texファイル内の参照を\ref{sec:refexp}項で''|の部分は常に
% \verb|\label{sec:refexp}|が付与された章を示します．

% 表や図のサンプルでもlabelとrefを利用しているので，本ソースコードをご確認ください．

% \subsubsection{文献の引用} \label{sec:ref}
% 引用のテスト\cite{IT人材白書2020}．
% これ\cite{yoon2012}もこれ\cite{sheil1983}もこれ\cite{sandeep2014}もテスト．
% 複数まとめて記述することもできます\cite{IT人材白書2020, yoon2012,sheil1983,sandeep2014}．
% 現状は引用順に参考文献が並びます．
% アルファベット順に引用文献を並べたいときは，本文末尾付近の\verb|\bibliographystyle{junsrt}|を\verb|\bibliographystyle{jplain}|に変更してください．

% コンパイル時に\verb|[??]|と表示されても，複数回コンパイルを行うと解決されることがあります．

\subsection{1回の実行で不具合発見するか}\label{chap:test1}
本節では，BiFuzzの1回の実行を1つのデータとし，その実行において不具合が発見されたか否かを予測対象とした場合の結果について述べる．
まず，比較対象として用意した本設定におけるベースラインの評価結果を表\ref{tab:baseline_result_1}に，今回のモデル構築に使用したデータセットの分布を表\ref{data_set_1}に示す．

\begin{table}[H]
  \centering
  \caption{ベースラインの評価結果 (\testfirst)}
  \label{tab:baseline_result_1}
  \begin{tabular}{l|r} \hline
    評価指標 & 値 \\ \hline \hline
    正解率 & 0.5764 \\
    適合率 & 0.5764 \\
    再現率 & 1.0000 \\
    F値 & 0.7313 \\ \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \caption{データセットの分布（\testfirst）}
  \label{data_set_1}
  \begin{tabular}{l|r} \hline
    分類 & 数 \\ \hline \hline
    不具合発見する & 6223\\
    不具合発見しない & 4577\\ \hline
  \end{tabular}
\end{table}

\paragraph{予測モデルの精度比較}
提案手法の有効性を検証するため，ロジスティック回帰分析，決定木，ランダムフォレストの3つのアルゴリズムを用いてモデルを構築した．各モデルの10分割交差検証による評価結果を表\ref{tab:logistic_single_metrics}，表\ref{tab:dt_single_metrics}，表\ref{tab:rf_single_metrics}に示す．

まず，ベースラインとの比較を行う．表\ref{tab:baseline_result_1}に示したベースラインのF値は0.7313であるのに対し，ロジスティック回帰分析（表\ref{tab:logistic_single_metrics}）のF値の平均は0.8397，決定木（表\ref{tab:dt_single_metrics}）およびランダムフォレスト（表\ref{tab:rf_single_metrics}）のF値の平均は0.8631となり，いずれのモデルもベースラインを上回る結果となった．
特に適合率に着目すると，ベースラインは0.5764と低い値に留まっているが，ロジスティック回帰分析では0.7932，決定木とランダムフォレストでは約0.8793まで向上している．これは，提案手法が不具合発見の可能性が高いケースを正確に識別できていることを示している．

次に，モデル間での比較を行う．決定木とランダムフォレストのF値平均は0.8631であり，ロジスティック回帰分析のF値0.8397と比較して約0.02高く，線型モデルよりも非線形モデルの方が，より高い精度で不具合発見を予測できていることが確認された．

\begin{table}[H]
    \caption{ロジスティック回帰分析の評価結果（\testfirst）}
    \label{tab:logistic_single_metrics}
    \centering
    \begin{tabular}{lcccc}
        \hline
        評価指標 & 平均値 & 標準偏差 & 最小値 & 最大値 \\\hline \hline
        正解率& 0.8036 & 0.0215 & 0.7704 & 0.8574 \\\hline
        適合率 & 0.7932 & 0.0199 & 0.7583 & 0.8431 \\\hline
        再現率 & 0.8922 & 0.0154 & 0.8732 & 0.9244 \\\hline
        F値 & 0.8397 & 0.0169 & 0.8158 & 0.8819 \\\hline
        AUC & 0.8288 & 0.0178 & 0.7994 & 0.8688 \\\hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{決定木の評価結果（\testfirst）}
    \label{tab:dt_single_metrics}
    \centering
    \begin{tabular}{lcccc}\hline
    評価指標 & 平均値 & 標準偏差 & 最小値 & 最大値 \\\hline \hline
    正解率 & 0.8451 & 0.0162 & 0.8167 & 0.8787 \\\hline
    適合率 & 0.8793 & 0.0158 & 0.8430 & 0.9085 \\\hline
    再現率 & 0.8477 & 0.0160 & 0.8266 & 0.8778 \\\hline
    F値 & 0.8631 & 0.0142 & 0.8403 & 0.8929 \\\hline
    AUC & 0.8648 & 0.0182 & 0.8303 & 0.9034\\\hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{ランダムフォレストの評価結果（\testfirst）}
    \label{tab:rf_single_metrics}
    \centering
    \begin{tabular}{lcccc}\hline 
        評価指標 & 平均値 & 標準偏差 & 最小値 & 最大値 \\\hline \hline
        正解率 & 0.8451 & 0.0162 & 0.8167 & 0.8787 \\\hline
        適合率 & 0.8793 & 0.0158 & 0.8430 & 0.9085 \\\hline
        再現率 & 0.8477 & 0.0160 & 0.8266 & 0.8778 \\\hline
        F値 & 0.8631 & 0.0142 & 0.8403 & 0.8929 \\\hline
        AUC & 0.8632 & 0.0171 & 0.8303 & 0.8976 \\\hline
    \end{tabular}
\end{table}

\paragraph{特徴量の分析}
各モデルにおいて，どのパラメータが不具合発見に寄与したかを分析する．
まず，ロジスティック回帰分析によって導出された回帰式を式(\ref{eq:logistic_single_split})に示す．

\begin{equation}
\begin{split}
    \label{eq:logistic_single_split}
    P &= \frac{1}{1 + \exp(-z)} \\
    \text{where, } z &= -1.788594 + 0.000146 \cdot tree + 0.001877 \cdot cpNum \\
      &\quad + 0.032893 \cdot cpNum\_range + 0.080988 \cdot cpNum\_dir
\end{split}
\end{equation}

式(\ref{eq:logistic_single_split})の係数に着目すると，$cpNum\_range$ や $cpNum\_dir$ が正の値を持っており，これらの値の増加が不具合発見確率の上昇に寄与していることがわかる．一方で，$tree$ の係数は0.000146と極めて小さく，影響は限定的である．

次に，決定木およびランダムフォレストにおける特徴量重要度を表\ref{tab:dt_single_importance}および表\ref{tab:rf_single_importance}に示す．
両モデルとも共通して $cpNum\_range$ が最も高い重要度（約69\%〜74\%）を示し，次いで $cpNum$ が重要（約26\%〜31\%）であるという結果が得られた．これら2つのパラメータで重要度全体の99\%以上を占めており，$tree$ や $cpNum\_dir$ の影響は無視できるほど小さい．

以上の結果から，使用するアルゴリズムに関わらず，経路生成に関するパラメータ（$cpNum\_range$, $cpNum$）が不具合発見に支配的な影響を与えており，マップ内の障害物数（$tree$）による影響は極めて小さいという共通した傾向が明らかになった．

\begin{table}[H]
    \caption{決定木における特徴量重要度（\testfirst）}
    \label{tab:dt_single_importance}
    \centering
    \begin{tabular}{lrrrr}\hline
        特徴量 & 平均重要度 & 標準偏差 & 最小値 & 最大値 \\\hline \hline
        cpNum\_range & 0.6891 & 0.0035 & 0.6802 & 0.6925\\\hline
        cpNum & 0.3083 & 0.0035 & 0.3042 & 0.3166 \\\hline
        tree & 0.0027 & 0.0004 & 0.0019 & 0.0034 \\\hline
        cpNum\_dir & 0.0000 & 0.0000 & 0.0000 & 0.0000 \\\hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{ランダムフォレストにおける特徴量重要度（\testfirst）}
    \label{tab:rf_single_importance}
    \centering
    \begin{tabular}{lrrrr}\hline 
        特徴量 & 平均重要度 & 標準偏差 & 最小値 & 最大値 \\\hline \hline
        cpNum\_range & 0.7389 & 0.0066 & 0.7277 & 0.7510\\\hline
        cpNum & 0.2582 & 0.0064 & 0.2467 & 0.2694 \\\hline
        tree & 0.0028 & 0.0004 & 0.0023 & 0.0038 \\\hline
        cpNum\_dir & 0.0000 & 0.0000 & 0.0000 & 0.0000 \\\hline
    \end{tabular}
\end{table}










\subsection{実験の考察}
以下では，実験結果に基づいてRQ1およびRQ2に対する回答を記述し，考察を行う．

\subsubsection*{RQ1: 提案手法によって不具合発見を予測できる有効なモデルは構築できるか}

本実験では，異なる3つの粒度で予測モデルの構築を試みた．
\cref{chap:test1}においては，決定木およびランダムフォレストを用いることで，ベースラインと比較してF値を約0.13向上させることができた．これは，提案手法によって構築したモデルによって，不具合発見の成否を一定の精度で予測可能であることを示している．

\cref{chap:test2}においては，ベースラインと比較して予測性能の向上は見られなかった．この要因として，実験データの偏りが挙げられる．\cref{data_set_2}より，本実験で収集したデータにおいて，不具合を発見できたテストケースは全体の約84\%を占めていた．このように正例の割合が極めて高い不均衡なデータセットであったため，学習されたモデルは特徴量に関わらず「不具合発見」と予測する傾向が強まり，すべてを正と予測するベースライン手法と差異が生じなかったことに起因すると考えられる．

\cref{chap:test3}においては，決定木およびランダムフォレストが高い再現率を達成した．
これは，再現性高く不具合を発見できるパラメータ設定を，モデルが高い精度で予測できていることを意味する．

\subsubsection*{RQ2: どのパラメータが予測に寄与したか？}

すべての実験設定およびすべての分析手法において，$tree$の特徴量重要度および回帰係数は，他のパラメータと比較して著しく低い値となった．この結果から，本実験で対象としたスタックする不具合に関しては，障害物の数，すなわちマップの構造が変化しても，不具合発見の成否には大きな影響を与えないと考えられる．

不具合発見に支配的な影響を与えているのは，プレイヤキャラクタの移動経路を決定する $cpNum\_range$ および $cpNum$ であった．マップの環境要因よりも，経路の生成方法が重要であると考えられる．

以上より，提案手法を用いることで，不具合発見の確率が高いパラメータ設定を予測する有効なモデルが構築できた．